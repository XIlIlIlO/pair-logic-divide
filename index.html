<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>엑셀 로직 생성기 (S & L Group)</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
        h1, h2, h3 { color: #2c3e50; }
        .container { max-width: 1000px; margin: 0 auto; }
        
        .section { background: #f9f9f9; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; }
        .upload-area { display: flex; gap: 20px; margin-bottom: 20px; }
        .upload-box { flex: 1; padding: 20px; border: 2px dashed #bbb; border-radius: 5px; text-align: center; background: #fff; }
        .upload-box.dragover { border-color: #3498db; background: #eaf6ff; }
        
        .input-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .input-group { display: flex; flex-direction: column; }
        .input-group label { margin-bottom: 5px; font-weight: bold; font-size: 0.9em; }
        .input-group input, .input-group textarea { padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .input-group textarea { height: 80px; resize: vertical; }

        .checkbox-group { margin: 15px 0; padding: 10px; background: #e8f8f5; border: 1px solid #a2d9ce; border-radius: 4px; }
        .checkbox-group label { font-weight: bold; color: #16a085; cursor: pointer; display: flex; align-items: center; gap: 10px; }
        .checkbox-group input[type="checkbox"] { transform: scale(1.5); }

        button { background-color: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; transition: background 0.3s; }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #95a5a6; cursor: not-allowed; }
        
        .btn-green { background-color: #27ae60; }
        .btn-green:hover { background-color: #219150; }

        #logArea { margin-top: 20px; padding: 10px; background: #333; color: #eee; border-radius: 5px; height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.9em; }
        
        .download-section { display: none; margin-top: 20px; padding: 20px; background-color: #e8f6f3; border: 1px solid #a2d9ce; border-radius: 8px; }
    </style>
</head>
<body>

<div class="container">
    <h1>엑셀 로직 생성기 (최적화 버전)</h1>
    <p>L그룹과 S그룹 엑셀 파일들을 업로드하여 로직을 생성합니다. (순환 매칭 알고리즘 적용)</p>

    <div class="section">
        <h2>1. 파일 업로드</h2>
        <div class="upload-area">
            <div class="upload-box" id="drop-l">
                <h3>L 그룹 파일들 (여러개 가능)</h3>
                <input type="file" id="files-l" multiple accept=".xlsx, .csv">
                <div class="file-list" id="list-l">선택된 파일 없음</div>
            </div>
            <div class="upload-box" id="drop-s">
                <h3>S 그룹 파일들 (여러개 가능)</h3>
                <input type="file" id="files-s" multiple accept=".xlsx, .csv">
                <div class="file-list" id="list-s">선택된 파일 없음</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>2. 로직 설정값 입력</h2>
        
        <div class="checkbox-group">
            <label>
                <input type="checkbox" id="chk-intersection">
                <span>순이익 양수 코인 중 "교집합(L과 S 모두 있는 코인)"만 대상으로 하기</span>
            </label>
            <div style="font-size: 0.85em; color: #555; margin-top: 5px; margin-left: 28px;">
                * 체크 시: L에서도 수익, S에서도 수익인 코인들끼리만 매칭합니다. (예: 30개 교집합 -> 30x30 = 900개)<br>
                * 체크 해제 시: 모든 수익 L코인과 모든 수익 S코인을 매칭합니다. (기존 방식)
            </div>
        </div>

        <div class="input-grid">
            <div class="input-group">
                <label for="val-b">B열: Start</label>
                <input type="text" id="val-b" value="10">
            </div>
            <div class="input-group">
                <label for="val-c">C열: Profit</label>
                <input type="text" id="val-c" value="11">
            </div>
            <div class="input-group">
                <label for="val-d">D열: Loss</label>
                <input type="text" id="val-d" value="393.5">
            </div>
            <div class="input-group">
                <label for="val-e">E열: Restart</label>
                <input type="text" id="val-e" value="-1">
            </div>
            <div class="input-group">
                <label for="val-f">F열: Leverage</label>
                <input type="text" id="val-f" value="20">
            </div>
            <div class="input-group" style="grid-column: span 2;">
                <label for="val-h">H열: DCA (줄바꿈 가능)</label>
                <textarea id="val-h">10,15,15
10,20,30
10,20,30</textarea>
            </div>
        </div>
        <hr>
        <div class="input-grid">
            <div class="input-group">
                <label for="split-count">파일 분할 최대 개수 (행 단위)</label>
                <input type="number" id="split-count" value="40" min="1">
            </div>
            <div class="input-group">
                <label for="file-name">다운로드 파일명 접두사</label>
                <input type="text" id="file-name" value="Result">
            </div>
        </div>
        <p style="font-size: 0.9em; color: #666;">* 순환 매칭 알고리즘 적용: 코인 개수(N)만큼의 파일이 생성되는 것이 기본이며, 분할 개수를 N보다 크게 설정하면 파일 개수가 최적화(최소화) 됩니다.</p>
        <div style="margin-top: 20px; text-align: center;">
            <button onclick="processFiles()">데이터 처리 및 결과 생성</button>
        </div>
    </div>

    <div id="download-section" class="download-section">
        <h2>3. 결과 다운로드</h2>
        <p id="result-summary"></p>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="btn-green" onclick="downloadIndividualList('L')">L 그룹 양수 리스트 다운로드</button>
            <button class="btn-green" onclick="downloadIndividualList('S')">S 그룹 양수 리스트 다운로드</button>
            <button onclick="downloadZippedResults()">분할된 로직 파일(ZIP) 다운로드</button>
        </div>
    </div>

    <div id="logArea">준비 완료.</div>
</div>

<script>
    let lData = [];
    let sData = [];
    let finalL = []; 
    let finalS = []; 
    let fileBuckets = []; // 수정됨: 평면 리스트 대신 완성된 파일 그룹 리스트 사용
    
    document.getElementById('files-l').addEventListener('change', (e) => updateFileList(e.target, 'list-l'));
    document.getElementById('files-s').addEventListener('change', (e) => updateFileList(e.target, 'list-s'));

    function log(msg) {
        const area = document.getElementById('logArea');
        area.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        area.scrollTop = area.scrollHeight;
    }

    function updateFileList(input, displayId) {
        const display = document.getElementById(displayId);
        if (input.files.length > 0) {
            display.textContent = `${input.files.length}개 파일 선택됨: ` + Array.from(input.files).map(f => f.name).join(', ');
        } else {
            display.textContent = "선택된 파일 없음";
        }
    }

    function getBaseSymbol(name) {
        return name.replace(/[+\-]$/, "").trim().toUpperCase();
    }

    async function processFiles() {
        const lFiles = document.getElementById('files-l').files;
        const sFiles = document.getElementById('files-s').files;
        const useIntersection = document.getElementById('chk-intersection').checked;

        if (lFiles.length === 0 || sFiles.length === 0) {
            alert("L 그룹과 S 그룹 파일을 모두 업로드해주세요.");
            return;
        }

        log("파일 처리를 시작합니다...");
        document.getElementById('download-section').style.display = 'none';

        try {
            const lMap = await parseAndMergeFiles(lFiles, 'L');
            const sMap = await parseAndMergeFiles(sFiles, 'S');

            const rawL = filterPositive(lMap);
            const rawS = filterPositive(sMap);

            log(`[기본] 순이익 양수 - L그룹: ${rawL.length}개, S그룹: ${rawS.length}개`);

            if (useIntersection) {
                log("옵션 적용: 교집합 코인만 추출합니다.");
                
                const lSymbols = new Set(rawL.map(item => getBaseSymbol(item.rawName)));
                const sSymbols = new Set(rawS.map(item => getBaseSymbol(item.rawName)));
                
                const intersection = new Set([...lSymbols].filter(x => sSymbols.has(x)));
                log(`교집합 코인 개수: ${intersection.size}개`);

                if (intersection.size === 0) {
                    alert("교집합 코인이 하나도 없습니다. 옵션을 해제하거나 파일을 다시 확인하세요.");
                    return;
                }

                finalL = rawL.filter(item => intersection.has(getBaseSymbol(item.rawName)));
                finalS = rawS.filter(item => intersection.has(getBaseSymbol(item.rawName)));
            } else {
                finalL = rawL;
                finalS = rawS;
            }

            finalL.sort((a, b) => b.profit - a.profit);
            finalS.sort((a, b) => b.profit - a.profit);

            log(`[최종 사용] L그룹: ${finalL.length}개, S그룹: ${finalS.length}개`);

            if (finalL.length === 0 || finalS.length === 0) {
                alert("처리할 데이터가 없습니다.");
                return;
            }

            // 4. 알고리즘 변경: 순환 매칭 실행
            runRotationMatching();

            // 총 조합 수 계산 (단순 표시용)
            let totalRows = 0;
            fileBuckets.forEach(b => totalRows += b.length);

            document.getElementById('result-summary').innerHTML = 
                `<strong>생성 결과:</strong> 총 ${totalRows}개의 로직이 ${fileBuckets.length}개 그룹(라운드)으로 준비됨.<br>` +
                `(최적화 알고리즘 적용 완료)`;
            document.getElementById('download-section').style.display = 'block';
            log("처리 완료! 다운로드 버튼을 이용하세요.");

        } catch (err) {
            console.error(err);
            log("에러 발생: " + err.message);
            alert("처리 중 오류가 발생했습니다. 로그를 확인하세요.");
        }
    }

    async function parseAndMergeFiles(fileList, type) {
        const mergedData = {}; 
        for (let file of fileList) {
            log(`${type} 파일 읽는 중: ${file.name}`);
            const data = await readExcelFile(file);
            
            let headerRowIndex = -1;
            for(let i=0; i<Math.min(20, data.length); i++) {
                const rowStr = JSON.stringify(data[i]);
                if (rowStr.includes("Group Name")) {
                    headerRowIndex = i;
                    break;
                }
            }

            if (headerRowIndex === -1) {
                log(`[주의] ${file.name}에서 'Group Name' 헤더를 찾을 수 없습니다. 건너뜁니다.`);
                continue;
            }

            const headerRow = data[headerRowIndex];
            let nameIdx = -1;
            let profitIdx = -1;

            headerRow.forEach((cell, idx) => {
                if (!cell) return;
                const c = cell.toString().trim();
                if (c === "Group Name") nameIdx = idx;
                if (c === "순이익" || c === "Net Profit") profitIdx = idx;
            });

            if (nameIdx === -1 || profitIdx === -1) continue;

            for (let i = headerRowIndex + 1; i < data.length; i++) {
                const row = data[i];
                if (!row || row.length <= nameIdx) continue;
                const name = row[nameIdx];
                const profit = parseFloat(row[profitIdx]);
                if (name && !isNaN(profit)) {
                    const groupName = name.toString().trim();
                    if (!mergedData[groupName]) {
                        mergedData[groupName] = { profit: 0, rawName: groupName };
                    }
                    mergedData[groupName].profit += profit;
                }
            }
        }
        return mergedData;
    }

    function readExcelFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                resolve(json);
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    function filterPositive(dataMap) {
        const list = [];
        for (const key in dataMap) {
            if (dataMap[key].profit > 0) {
                list.push(dataMap[key]);
            }
        }
        return list;
    }

    // ★ 수정된 알고리즘: 순환 매칭 (Rotation Matching) ★
    function runRotationMatching() {
        fileBuckets = []; // 초기화

        const valB = document.getElementById('val-b').value;
        const valC = document.getElementById('val-c').value;
        const valD = document.getElementById('val-d').value;
        const valE = document.getElementById('val-e').value;
        const valF = document.getElementById('val-f').value;
        const valH = document.getElementById('val-h').value;

        // 1. 리스트 길이 맞추기 (더미 추가로 N x N 정사각형 격자 생성)
        const N = Math.max(finalL.length, finalS.length);
        const listL = [...finalL];
        const listS = [...finalS];

        // 부족한 부분을 null로 채움
        while(listL.length < N) listL.push(null);
        while(listS.length < N) listS.push(null);

        // 2. N라운드 진행 (0 ~ N-1)
        for (let round = 0; round < N; round++) {
            const currentRoundRows = [];

            for (let i = 0; i < N; i++) {
                // L은 고정, S는 round만큼 시프트하여 매칭
                const itemL = listL[i];
                const itemS = listS[(i + round) % N];

                // 둘 다 실제 데이터일 경우에만 행 생성
                if (itemL && itemS) {
                    const lName = itemL.rawName; 
                    const sName = itemS.rawName; 
                    
                    const groupNameCol = `${lName} ${sName}`;
                    const lSymbolRaw = lName.replace(/[+\-]$/, "");
                    const sSymbolRaw = sName.replace(/[+\-]$/, "");
                    const symbolsCol = `${lSymbolRaw}USDT,L\n${sSymbolRaw}USDT,S`;

                    const row = [
                        groupNameCol, valB, valC, valD, valE, valF, symbolsCol, valH, null
                    ];
                    currentRoundRows.push(row);
                }
            }

            // 이번 라운드에 생성된 행이 있다면 버킷에 추가
            // (이 버킷 안에서는 L도 S도 절대 중복되지 않음이 수학적으로 보장됨)
            if (currentRoundRows.length > 0) {
                fileBuckets.push(currentRoundRows);
            }
        }
    }

    function setColumnWidth(ws) {
        const wscols = [];
        for(let i=0; i<9; i++) {
            wscols.push({wch: 14});
        }
        ws['!cols'] = wscols;
    }

    function downloadIndividualList(type) {
        const data = type === 'L' ? finalL : finalS;
        if (!data || data.length === 0) {
            alert("다운로드할 데이터가 없습니다.");
            return;
        }

        const wsData = [["Group Name", "Total Net Profit"]];
        data.forEach(item => {
            wsData.push([item.rawName, item.profit]);
        });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        ws['!cols'] = [{wch: 20}, {wch: 15}];
        XLSX.utils.book_append_sheet(wb, ws, "Result");
        XLSX.writeFile(wb, `${type}_Group_Filtered_List.xlsx`);
    }

    function downloadZippedResults() {
        if (fileBuckets.length === 0) {
            alert("생성된 로직 데이터가 없습니다.");
            return;
        }

        const maxRows = parseInt(document.getElementById('split-count').value) || 40;
        const baseName = document.getElementById('file-name').value || "Result";
        const zip = new JSZip();

        log(`파일 생성 및 압축 시작... (최대 행 수: ${maxRows})`);

        let fileIndex = 1;
        const header = ["GroupName", "Start", "Profit", "Loss", "Restart", "Leverage", "Symbols", "DCA", "PRM"];

        // 수정된 다운로드 로직: 이미 만들어진 fileBuckets(라운드)를 순회
        // 각 라운드는 이미 중복이 없음. 만약 라운드의 크기가 maxRows보다 크다면 쪼개서 저장.
        fileBuckets.forEach((bucketRows) => {
            for (let i = 0; i < bucketRows.length; i += maxRows) {
                const chunk = bucketRows.slice(i, i + maxRows);
                
                const wsData = [header, ...chunk];
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(wsData);
                
                setColumnWidth(ws);

                XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
                const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
                zip.file(`${baseName}_${fileIndex}.xlsx`, excelBuffer);
                fileIndex++;
            }
        });

        zip.generateAsync({type:"blob"})
        .then(function(content) {
            saveAs(content, `${baseName}_Optimized_Files.zip`);
            log("다운로드 완료.");
        });
    }
</script>

</body>
</html>
