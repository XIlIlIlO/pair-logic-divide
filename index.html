<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>엑셀 로직 생성기 (S & L Group)</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
        h1, h2, h3 { color: #2c3e50; }
        .container { max-width: 1000px; margin: 0 auto; }
        
        .section { background: #f9f9f9; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; }
        .upload-area { display: flex; gap: 20px; margin-bottom: 20px; }
        .upload-box { flex: 1; padding: 20px; border: 2px dashed #bbb; border-radius: 5px; text-align: center; background: #fff; }
        .upload-box.dragover { border-color: #3498db; background: #eaf6ff; }
        
        .input-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .input-group { display: flex; flex-direction: column; }
        .input-group label { margin-bottom: 5px; font-weight: bold; font-size: 0.9em; }
        .input-group input, .input-group textarea { padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .input-group textarea { height: 80px; resize: vertical; }

        .checkbox-group { margin: 15px 0; padding: 10px; background: #e8f8f5; border: 1px solid #a2d9ce; border-radius: 4px; }
        .checkbox-group label { font-weight: bold; color: #16a085; cursor: pointer; display: flex; align-items: center; gap: 10px; }
        .checkbox-group input[type="checkbox"] { transform: scale(1.5); }

        button { background-color: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; transition: background 0.3s; }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #95a5a6; cursor: not-allowed; }
        
        .btn-green { background-color: #27ae60; }
        .btn-green:hover { background-color: #219150; }

        #logArea { margin-top: 20px; padding: 10px; background: #333; color: #eee; border-radius: 5px; height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.9em; }
        
        .download-section { display: none; margin-top: 20px; padding: 20px; background-color: #e8f6f3; border: 1px solid #a2d9ce; border-radius: 8px; }
    </style>
</head>
<body>

<div class="container">
    <h1>엑셀 로직 생성기</h1>
    <p>L그룹과 S그룹 엑셀 파일들을 업로드하여 로직을 생성합니다. (파일 내 코인 중복 방지 적용)</p>

    <div class="section">
        <h2>1. 파일 업로드</h2>
        <div class="upload-area">
            <div class="upload-box" id="drop-l">
                <h3>L 그룹 파일들 (여러개 가능)</h3>
                <input type="file" id="files-l" multiple accept=".xlsx, .csv">
                <div class="file-list" id="list-l">선택된 파일 없음</div>
            </div>
            <div class="upload-box" id="drop-s">
                <h3>S 그룹 파일들 (여러개 가능)</h3>
                <input type="file" id="files-s" multiple accept=".xlsx, .csv">
                <div class="file-list" id="list-s">선택된 파일 없음</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>2. 로직 설정값 입력</h2>
        
        <div class="checkbox-group">
            <label>
                <input type="checkbox" id="chk-intersection">
                <span>순이익 양수 코인 중 "교집합(L과 S 모두 있는 코인)"만 대상으로 하기</span>
            </label>
            <div style="font-size: 0.85em; color: #555; margin-top: 5px; margin-left: 28px;">
                * 체크 시: L에서도 수익, S에서도 수익인 코인들끼리만 매칭합니다. (예: 30개 교집합 -> 30x30 = 900개)<br>
                * 체크 해제 시: 모든 수익 L코인과 모든 수익 S코인을 매칭합니다. (기존 방식)
            </div>
        </div>

        <div class="input-grid">
            <div class="input-group">
                <label for="val-b">B열: Start</label>
                <input type="text" id="val-b" value="10">
            </div>
            <div class="input-group">
                <label for="val-c">C열: Profit</label>
                <input type="text" id="val-c" value="11">
            </div>
            <div class="input-group">
                <label for="val-d">D열: Loss</label>
                <input type="text" id="val-d" value="393.5">
            </div>
            <div class="input-group">
                <label for="val-e">E열: Restart</label>
                <input type="text" id="val-e" value="-1">
            </div>
            <div class="input-group">
                <label for="val-f">F열: Leverage</label>
                <input type="text" id="val-f" value="20">
            </div>
            <div class="input-group" style="grid-column: span 2;">
                <label for="val-h">H열: DCA (줄바꿈 가능)</label>
                <textarea id="val-h">10,15,15
10,20,30
10,20,30</textarea>
            </div>
        </div>
        <hr>
        <div class="input-grid">
            <div class="input-group">
                <label for="split-count">파일 분할 최대 개수 (행 단위)</label>
                <input type="number" id="split-count" value="40" min="1">
            </div>
            <div class="input-group">
                <label for="file-name">다운로드 파일명 접두사</label>
                <input type="text" id="file-name" value="Result">
            </div>
        </div>
        <p style="font-size: 0.9em; color: #666;">* 같은 파일 내에 동일 코인(L 또는 S)이 중복되지 않도록 분할하므로, 설정한 개수보다 적게 담길 수 있습니다.</p>
        <div style="margin-top: 20px; text-align: center;">
            <button onclick="processFiles()">데이터 처리 및 결과 생성</button>
        </div>
    </div>

    <div id="download-section" class="download-section">
        <h2>3. 결과 다운로드</h2>
        <p id="result-summary"></p>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="btn-green" onclick="downloadIndividualList('L')">L 그룹 양수 리스트 다운로드</button>
            <button class="btn-green" onclick="downloadIndividualList('S')">S 그룹 양수 리스트 다운로드</button>
            <button onclick="downloadZippedResults()">분할된 로직 파일(ZIP) 다운로드</button>
        </div>
    </div>

    <div id="logArea">준비 완료.</div>
</div>

<script>
    let lData = [];
    let sData = [];
    let finalL = []; // 필터링(교집합 여부 등)된 최종 리스트
    let finalS = []; 
    let allCombinations = []; 
    
    document.getElementById('files-l').addEventListener('change', (e) => updateFileList(e.target, 'list-l'));
    document.getElementById('files-s').addEventListener('change', (e) => updateFileList(e.target, 'list-s'));

    function log(msg) {
        const area = document.getElementById('logArea');
        area.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
        area.scrollTop = area.scrollHeight;
    }

    function updateFileList(input, displayId) {
        const display = document.getElementById(displayId);
        if (input.files.length > 0) {
            display.textContent = `${input.files.length}개 파일 선택됨: ` + Array.from(input.files).map(f => f.name).join(', ');
        } else {
            display.textContent = "선택된 파일 없음";
        }
    }

    // 코인 기본 이름 추출 (예: BTC+ -> BTC, ETH- -> ETH)
    function getBaseSymbol(name) {
        return name.replace(/[+\-]$/, "").trim().toUpperCase();
    }

    async function processFiles() {
        const lFiles = document.getElementById('files-l').files;
        const sFiles = document.getElementById('files-s').files;
        const useIntersection = document.getElementById('chk-intersection').checked;

        if (lFiles.length === 0 || sFiles.length === 0) {
            alert("L 그룹과 S 그룹 파일을 모두 업로드해주세요.");
            return;
        }

        log("파일 처리를 시작합니다...");
        document.getElementById('download-section').style.display = 'none';

        try {
            // 1. 데이터 파싱 및 통합
            const lMap = await parseAndMergeFiles(lFiles, 'L');
            const sMap = await parseAndMergeFiles(sFiles, 'S');

            // 2. 순이익 양수 필터링
            const rawL = filterPositive(lMap);
            const rawS = filterPositive(sMap);

            log(`[기본] 순이익 양수 - L그룹: ${rawL.length}개, S그룹: ${rawS.length}개`);

            // 3. 교집합 필터링 여부 확인
            if (useIntersection) {
                log("옵션 적용: 교집합 코인만 추출합니다.");
                
                // 각 리스트의 베이스 심볼 집합 생성
                const lSymbols = new Set(rawL.map(item => getBaseSymbol(item.rawName)));
                const sSymbols = new Set(rawS.map(item => getBaseSymbol(item.rawName)));
                
                // 교집합 찾기
                const intersection = new Set([...lSymbols].filter(x => sSymbols.has(x)));
                log(`교집합 코인 개수: ${intersection.size}개`);

                if (intersection.size === 0) {
                    alert("교집합 코인이 하나도 없습니다. 옵션을 해제하거나 파일을 다시 확인하세요.");
                    return;
                }

                // 교집합에 해당하는 항목만 남기기
                finalL = rawL.filter(item => intersection.has(getBaseSymbol(item.rawName)));
                finalS = rawS.filter(item => intersection.has(getBaseSymbol(item.rawName)));
            } else {
                finalL = rawL;
                finalS = rawS;
            }

            // 정렬 (순이익 내림차순)
            finalL.sort((a, b) => b.profit - a.profit);
            finalS.sort((a, b) => b.profit - a.profit);

            log(`[최종 사용] L그룹: ${finalL.length}개, S그룹: ${finalS.length}개`);

            if (finalL.length === 0 || finalS.length === 0) {
                alert("처리할 데이터가 없습니다.");
                return;
            }

            // 4. 조합 로직 데이터 생성
            prepareCombinations();

            document.getElementById('result-summary').innerHTML = 
                `<strong>생성 결과:</strong> 총 ${allCombinations.length}개의 조합 로직 준비됨. ` +
                `(L: ${finalL.length}개 × S: ${finalS.length}개)`;
            document.getElementById('download-section').style.display = 'block';
            log("처리 완료! 다운로드 버튼을 이용하세요.");

        } catch (err) {
            console.error(err);
            log("에러 발생: " + err.message);
            alert("처리 중 오류가 발생했습니다. 로그를 확인하세요.");
        }
    }

    async function parseAndMergeFiles(fileList, type) {
        const mergedData = {}; 

        for (let file of fileList) {
            log(`${type} 파일 읽는 중: ${file.name}`);
            const data = await readExcelFile(file);
            
            // 헤더 행 찾기
            let headerRowIndex = -1;
            for(let i=0; i<Math.min(20, data.length); i++) {
                const rowStr = JSON.stringify(data[i]);
                if (rowStr.includes("Group Name")) {
                    headerRowIndex = i;
                    break;
                }
            }

            if (headerRowIndex === -1) {
                log(`[주의] ${file.name}에서 'Group Name' 헤더를 찾을 수 없습니다. 건너뜁니다.`);
                continue;
            }

            const headerRow = data[headerRowIndex];
            let nameIdx = -1;
            let profitIdx = -1;

            headerRow.forEach((cell, idx) => {
                if (!cell) return;
                const c = cell.toString().trim();
                if (c === "Group Name") nameIdx = idx;
                if (c === "순이익" || c === "Net Profit") profitIdx = idx;
            });

            if (nameIdx === -1 || profitIdx === -1) {
                continue;
            }

            for (let i = headerRowIndex + 1; i < data.length; i++) {
                const row = data[i];
                if (!row || row.length <= nameIdx) continue;

                const name = row[nameIdx];
                const profit = parseFloat(row[profitIdx]);

                if (name && !isNaN(profit)) {
                    const groupName = name.toString().trim();
                    if (!mergedData[groupName]) {
                        mergedData[groupName] = { profit: 0, rawName: groupName };
                    }
                    mergedData[groupName].profit += profit;
                }
            }
        }
        return mergedData;
    }

    function readExcelFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                resolve(json);
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    function filterPositive(dataMap) {
        const list = [];
        for (const key in dataMap) {
            if (dataMap[key].profit > 0) {
                list.push(dataMap[key]);
            }
        }
        return list;
    }

    function prepareCombinations() {
        allCombinations = [];
        const valB = document.getElementById('val-b').value;
        const valC = document.getElementById('val-c').value;
        const valD = document.getElementById('val-d').value;
        const valE = document.getElementById('val-e').value;
        const valF = document.getElementById('val-f').value;
        const valH = document.getElementById('val-h').value;

        for (let lItem of finalL) {
            for (let sItem of finalS) {
                const lName = lItem.rawName; 
                const sName = sItem.rawName; 
                
                const groupNameCol = `${lName} ${sName}`;
                const lSymbolRaw = lName.replace(/[+\-]$/, "");
                const sSymbolRaw = sName.replace(/[+\-]$/, "");
                const symbolsCol = `${lSymbolRaw}USDT,L\n${sSymbolRaw}USDT,S`;

                const row = [
                    groupNameCol, // A
                    valB,         // B
                    valC,         // C
                    valD,         // D
                    valE,         // E
                    valF,         // F
                    symbolsCol,   // G
                    valH,         // H
                    null          // I
                ];
                
                allCombinations.push({
                    lName: lName,
                    sName: sName,
                    rowData: row
                });
            }
        }
    }

    // 열 너비 설정 헬퍼 함수
    function setColumnWidth(ws) {
        // A~I열 (9개) 모두 너비 14로 설정
        const wscols = [];
        for(let i=0; i<9; i++) {
            wscols.push({wch: 14});
        }
        ws['!cols'] = wscols;
    }

    function downloadIndividualList(type) {
        const data = type === 'L' ? finalL : finalS;
        if (!data || data.length === 0) {
            alert("다운로드할 데이터가 없습니다.");
            return;
        }

        const wsData = [["Group Name", "Total Net Profit"]];
        data.forEach(item => {
            wsData.push([item.rawName, item.profit]);
        });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        
        // 열 너비 설정
        ws['!cols'] = [{wch: 20}, {wch: 15}]; // 이름은 좀 더 길게, 순이익은 적당히

        XLSX.utils.book_append_sheet(wb, ws, "Result");
        XLSX.writeFile(wb, `${type}_Group_Filtered_List.xlsx`);
    }

    function downloadZippedResults() {
        if (allCombinations.length === 0) {
            alert("생성된 로직 데이터가 없습니다.");
            return;
        }

        const maxRows = parseInt(document.getElementById('split-count').value) || 40;
        const baseName = document.getElementById('file-name').value || "Result";
        const zip = new JSZip();

        log(`중복 방지 분할 작업 시작 (최대 ${maxRows}행/파일)...`);

        let buckets = [];

        // First Fit with Constraints 알고리즘
        for (let item of allCombinations) {
            let placed = false;
            for (let bucket of buckets) {
                if (bucket.rows.length >= maxRows) continue;
                if (bucket.usedL.has(item.lName) || bucket.usedS.has(item.sName)) continue;

                bucket.rows.push(item.rowData);
                bucket.usedL.add(item.lName);
                bucket.usedS.add(item.sName);
                placed = true;
                break;
            }

            if (!placed) {
                const newBucket = {
                    rows: [item.rowData],
                    usedL: new Set([item.lName]),
                    usedS: new Set([item.sName])
                };
                buckets.push(newBucket);
            }
        }

        log(`총 ${buckets.length}개의 파일로 분할되었습니다. (압축 시작...)`);

        const header = ["GroupName", "Start", "Profit", "Loss", "Restart", "Leverage", "Symbols", "DCA", "PRM"];

        buckets.forEach((bucket, index) => {
            const wsData = [header, ...bucket.rows];
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            
            // 열 너비 설정 (모든 열 14)
            setColumnWidth(ws);

            XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
            const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            zip.file(`${baseName}_${index + 1}.xlsx`, excelBuffer);
        });

        zip.generateAsync({type:"blob"})
        .then(function(content) {
            saveAs(content, `${baseName}_Split_Files.zip`);
            log("다운로드 완료.");
        });
    }
</script>

</body>
</html>
